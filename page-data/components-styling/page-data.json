{"componentChunkName":"component---src-layout-post-tsx","path":"/components-styling/","result":{"data":{"markdownRemark":{"html":"<p>이번에는 코드스테이츠 WEWIN 제품 개발팀에 Front-end 개발자로 합류하면서 내가 기존 코드들을 보고 가장 처음 고민하고 개발 방향을 설정하면서 다른 개발자 분들께 이유와 의도를 전달하기 위해 작성한 글을 기반으로 기록을 남겨 보려 한다.</p>\n<h2>발단</h2>\n<p>제품에 대한 온보딩을 진행하면서 기존에 작성된 코드들을 살펴보게 되었고 당장 큰 범위의 기능 개발이 없었기 때문에 시간적 여유가 있다고 생각해 제품 코드에 대한 이해도를 높일겸 리팩토링을 진행하려 했다.\n<img src=\"https://user-images.githubusercontent.com/71566740/175810773-a339fb4c-b0d8-4c2d-8044-d031d0a75915.jpeg\" alt=\"refactoring\"></p>\n<p>내가 가장 처음 느꼈던 부분은 기존 코드가 여러 개발자 분들의 손을 거치다보니 여러 라이브러리와 스타일링 방법이 혼재되어있다는 부분이었다.</p>\n<p>우선 <a href=\"https://chakra-ui.com/\">Chakra-ui</a>를 기반으로 주로 CSS-in-JS 방식의 emotion과 styled-components가 혼재되어있었고 중간중간 리렌더링을 고려하지 않은 inline-style 코드들이 보였다.</p>\n<p>CSS-in-JS 방식 자체는 요즘 트렌드이기도 하고 WEWIN의 제품이 성능 자체가 중요한것은 아니라고 판단되었기 때문에 그리 큰 문제는 아니었지만 이런식의 스타일링 컨벤션이 없는 상태로 제품 개발이 계속 진행되다 보면 결국 기술부채가 쌓이고 언젠가 이를 상환하기 위해 더 큰 리소스를 투입해야 된다고 생각했기 때문에 아직 제품 코드가 쌓이기 전에 이를 정리하고 가고싶다는 생각이었다.</p>\n<h2>컴포넌트 스타일링 스택 후보</h2>\n<p>다음은 내가 고민했던 기술 스택들에 대한 장단점과 나의 의견을 정리해본것이다.</p>\n<p>우선 다음과 같은 이유에서 inline-style로 작성된 코드들은 적용범위가 적고 우선순위가 높아 편리하지만 렌더링 할때마다 객체 주소가 바뀌고 이를 리액트는 가상 DOM 변화라고 인식하기 때문에 불필요한 리렌더를 발생시켜 제외하고 꼭 필요한 경우가 아니라면 최대한 걷어내기로 했다.</p>\n<p>물론 css 객체를 메모제이션 하면 이부분은 일정 부분 해소 가능하지만 굳이 CSS-in-JS 방식에 좋은 대안들이 많은데 이방법을 사용하는건 비효율 적이라는 생각이다.</p>\n<h3><svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><title>JavaScript</title><path d=\"M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z\"/></svg> CSS-in-JS</h3>\n<h4>장점</h4>\n<ul>\n<li>필요한 컴포넌트 페이지의 스타일 요소만 로딩함</li>\n<li>파일 관리가 편함 / 컴포넌트간 완전한 분리가 보장 / 모듈성</li>\n<li>스타일링 우선순위에 대한 고민이 비교적 적음</li>\n<li>JS 환경을 최대한 활용함</li>\n<li>자바스크립트와 CSS 사이의 상수와 함수를 공유함 (이부분이 가장 포기하기 힘든 부분)</li>\n<li>트렌디함 / 요즘 많은 개발자들이 선호하는 방식</li>\n</ul>\n<h4>단점</h4>\n<ul>\n<li>CSS-in-CSS 방식에 비해 성능이 떨어짐<br/>\n<a href=\"https://pustelto.com/blog/css-vs-css-in-js-perf/\">Tomas Pustelnik / Real-world CSS vs. CSS-in-JS performance comparison</a><br/> (요약하자면 앱의 속도 개선을 위해서는 JS 절대량을 줄여라)</li>\n<li>스크립트 파일의 크기가 커지면 가독성을 해침 (특히 포메터를 사용할 경우)</li>\n</ul>\n<h4>관련 스택</h4>\n<ul>\n<li>Emotion</li>\n<li>Styled-Components</li>\n</ul>\n<p>만약 위 두 기술스택중 선택한다면 Emotion을 선택할것 같다.</p>\n<p>잘 정리된 포스트가 있는데 가서 읽어 보는것도 좋을것 같다.<br/><a href=\"https://velog.io/@bepyan/styled-components-%EA%B3%BC-emotion-%EB%8F%84%EB%8C%80%EC%B2%B4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%94%EA%B0%80\">bepyan.log / styled-components 과 emotion, 도대체 차이가 뭔가?</a></p>\n<h3><svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><title>CSS3</title><path d=\"M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z\"/></svg> CSS-in-CSS</h3>\n<h4>장점</h4>\n<ul>\n<li>가장 일반적이고 기초적인 스타일링 방법이기 때문에 Front-end 추후 합류할 다른 개발자들도 별도의 학습이 필요없다.<br/>(물론 CSS에서 제공하는 모든 기능을 잘 쓰냐는 다른 문제)</li>\n<li>CSS-in-JS 방식보다 일반적인 상황에서 빠름</li>\n<li>추가적인 의존성 없이 사용 가능</li>\n<li>CSS-in-JS 방식보다 재사용성이 조금더 낫다는 생각</li>\n<li>Stylesheet 파일 분리로 인해 준수한 가독성</li>\n</ul>\n<h4>단점</h4>\n<ul>\n<li>변동적인 값에 대한 핸들링이 불편함</li>\n<li>디테일한 컨벤션 없이는 규모가 커질수록 협업이 힘들 수 있음 (클래스 속성 중복등)</li>\n<li>파일 구조에 대한 고민이 필요함</li>\n<li>우선순위에 대한 많은 고민이 필요함</li>\n</ul>\n<h4>관련 스택</h4>\n<ul>\n<li>CSS-Modules</li>\n<li>SASS(SCSS)</li>\n</ul>\n<h2>최종 선택</h2>\n<p>결론적으로 나는 SCSS 형식을 사용해 CSS-Modules 방식으로 리팩토링을 진행하기로 했다.</p>\n<p>여러가지 이유가 있겠지만 내가 가장 끌렸던 부분은 성능적인 부분이다.<br/> (참고로 나는 JS 내장함수들도 브라우저별 성능을 비교해보고 쓸정도로 최적화에 관심이 많다.)\n<img src=\"https://user-images.githubusercontent.com/71566740/175810705-f4a0009e-b7db-49a9-a2d4-5c704b51cd47.jpeg\" alt=\"Choice-or-Decision-in-Chinese\"></p>\n<p>사실 WEWIN 제품들 그렇게 성능이 크게 필요한 제품도 아니고 SSR 방식으로 배포한다고 가정하면 더더욱 성능에서는 차이가 없다.</p>\n<p>하지만 현재 우리는 교육 기업들이 학생관리에 사용할 B2B 어드민과 실제 학생들이 보게될 B2C 페이지, 코드스테이츠 내부 크루들이 사용할 백오피스 어드민 이렇게 총 3가지를 개발하고 있다.</p>\n<p>이중 SSR이 필요한 제품은 B2C 페이지 밖에 없기 때문에 SSR을 상정하고 개발을 진행하기엔 무리가 있다.</p>\n<p>현재는 미세한 차이긴 하지만 나중에는 어떤기능을 지원하게 될지 모르는 상황에서 이런 성능적 이점을 챙기지 않을 이유가 없었다.<br/>(기존 코드가 대부분 CSS-in-JS 방식으로 작성되었기 때문에 할일이 더 많아지긴 했지만)</p>\n<p>그리고 내 기준으로 CSS-in-CSS 방식이 가독성이 좀더 좋다고 느꼈다.</p>\n<h3>SASS를 사용한 이유</h3>\n<p>기본 CSS 대신 SASS를 사용한 이유는 여러기지 편의성 함수들과 스타일시트간 import의 성능 차이 때문이다<br/>(기본적으로 CSS의 @import는 병렬적으로 처리되지 않는다.)</p>\n<p>관련된 내용들은 다음 포스트에 잘 정리되어있다.<br/>\n<a href=\"https://yceffort.kr/2021/03/improve-css-performance\">yceffort / CSS 성능 향상 시키기</a></p>\n<p>최근에 SASS에서 지원하는 여러 가지 기능들이 CSS에서도 지원되기 시작했지만 아직 실험적인 기능들이 많고 브라우저별 호환성도 천차만별이라 SASS를 선택했다.</p>\n<h3>CSS-Modules을 사용한 이유</h3>\n<p>CSS-Modules을 사용한 이유는 CSS-in-JS처럼 컴포넌트 간 분리를 원했으며 클래스명 작명 컨벤션을 만드는 것보다 컴포넌트 단위로 스타일시트가 종속되는 게 구조 파악에 용이하고 생각했기 때문이다.</p>\n<p>조금 덧붙이자면 Next.js는 <a href=\"https://nextjs.org/blog/next-9-3#built-in-sass-css-module-support-for-component-level-styles\">9.3 ver</a> 이후 CSS-Modules 방식을 권장했다.</p>\n<p>B2C 페이지에 Next.js 도입을 고려하는 상황에서 CSS-Modules을 사용하는 방향으로 컨벤션을 확립한다면 추후 발생 가능한 혼란을 최소화할 수 있다고 생각했다.</p>\n<p><br/>내 개인적인 선호가 영향을 주지 않았다면 거짓말이겠지만 적어도 레퍼런스와 고민 없이 선택한 것이 아니라고 말하고 싶다.</p>\n<p>추가적으로 이러한 방 밥을 적용하고 이후 개발 패턴을 적용했을 때 효율적인 파일 구조가 어떤 것 일지 고민해봐야 할 것 같다.</p>","frontmatter":{"title":"리액트 컴포넌트 스타일링 정리","titleImage":"https://user-images.githubusercontent.com/71566740/175779283-54f3f2d0-77eb-4326-8a30-217669e5e262.gif","date":"2022-03-12","description":"리액트 기반 제품을 개발하면서 고민했던 컴포넌트 스타일링 방법에 대한 고민","tags":["Frontend"]},"fields":{"slug":"/components-styling/"},"id":"269686d6-2fed-5692-8516-65172b3d1780"},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/components-styling/"},"frontmatter":{"description":"리액트 기반 제품을 개발하면서 고민했던 컴포넌트 스타일링 방법에 대한 고민","title":"리액트 컴포넌트 스타일링 정리"},"id":"269686d6-2fed-5692-8516-65172b3d1780"},{"fields":{"slug":"/employment-memoirs/"},"frontmatter":{"description":"평범한 대학생 개발자의 2022년 상반기 취업과정","title":"대학생 개발자 취업 회고"},"id":"055ba126-a39c-5c44-809e-346a02a0a77f"},{"fields":{"slug":"/blog-remake-review2/"},"frontmatter":{"description":"Next.js에서 Gatsby로 블로그를 이전하고 느낀점","title":"Gatsby 블로그 이전"},"id":"22ea3c6e-ee50-5be3-9bbb-41a417e827a3"},{"fields":{"slug":"/covid-19-api-update/"},"frontmatter":{"description":"단계적 일상회복에 따른 Covid-19 API 업데이트","title":"Covid-19 API 업데이트"},"id":"55aa1525-7329-548e-aed0-321afe5356f4"},{"fields":{"slug":"/korea-webtoon-api-update/"},"frontmatter":{"description":"Daum 웹툰의 개편으로 인한 API 업데이트","title":"Webtoon API 업데이트"},"id":"a21d2ce7-380a-51aa-a12b-82493d52ed65"},{"fields":{"slug":"/nest-js/"},"frontmatter":{"description":"Typescript를 이용한 NestJS 코드 작성","title":"NestJS 웹서버 구축하기"},"id":"e0917e2d-f9da-5e98-80c6-683285770a39"},{"fields":{"slug":"/knu-lms-scheduler/"},"frontmatter":{"description":"공주대학교 비대면 강의 시스템 편의성 개선 프로젝트","title":"KNU LMS Scheduler 프로젝트"},"id":"02f53968-0d2e-52f9-86d7-821a0b02bb84"},{"fields":{"slug":"/gititle-project/"},"frontmatter":{"description":"좋은 커밋 메시지를 작성하기 위한 프로젝트","title":"Gititle 프로젝트"},"id":"b735da78-589b-5db1-aabe-d37b462d14c4"},{"fields":{"slug":"/sass-compiler/"},"frontmatter":{"description":"편리한 Sass 사용을 위한 익스텐션","title":"Live Sass Compiler 사용하기"},"id":"26bcefd2-68b7-57b9-a09c-a1821036c97a"},{"fields":{"slug":"/nodejs-crawling/"},"frontmatter":{"description":"Node.js 크롤링을 통한 데이터 수집","title":"크롤링을 통한 데이터 수집하기"},"id":"55c0d50a-b858-5b39-84e9-cdbce6c96d2d"},{"fields":{"slug":"/copilot-review/"},"frontmatter":{"description":"Github의 코딩 AI, Copilot 한 달 사용 리뷰","title":"Copilot 사용 후기"},"id":"0a34d6a1-3a25-5f66-bf8e-b8acc1732d0c"},{"fields":{"slug":"/typescript-express/"},"frontmatter":{"description":"Typescript를 이용한 Express 코드 작성","title":"Typescript + Express 웹서버 구축하기"},"id":"7d8d7f08-3bb7-55da-bce3-d3f039c53410"},{"fields":{"slug":"/blog-remake-review1/"},"frontmatter":{"description":"Next.js에서 Gatsby로 블로그를 이전하면서 느낀점","title":"Gatsby 블로그 이전 중간 리뷰"},"id":"a4c7e066-97b3-5e56-b34a-caccc301816d"},{"fields":{"slug":"/good-commit-message/"},"frontmatter":{"description":"Git Commit Message 작성을 위한 나와의 약속","title":"Git Commit Message Convention"},"id":"391e810d-0a42-537f-8214-11c776f8dedc"}]}},"pageContext":{"slug":"/components-styling/"}},"staticQueryHashes":[]}