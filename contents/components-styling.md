---
title: "컴포넌트 스타일링에 대한 고민"
titleImage: "https://user-images.githubusercontent.com/71566740/175779283-54f3f2d0-77eb-4326-8a30-217669e5e262.gif"
description: "리액트 기반 제품을 개발하면서 했던 컴포넌트 스타일링에 대한 고민과 회고"
date: "2022-03-12"
tags: [Frontend]
---

이번에는 코드스테이츠 WEWIN 제품 개발팀에 Front-end 개발자로 합류하면서 내가 기존 코드들을 보고 가장 처음 고민하고 개발 방향을 설정하면서 기존 개발자 분들을 설득하기 위해 작성한 글을 기반으로 기록을 남겨 보려 한다.

## 발단

제품에 대한 온보딩을 진행하면서 기존에 작성된 코드들을 살펴보게 되었고 당장 큰 범위의 기능 개발이 없었기 떄문에 시간적 여유가 있다고 생각해 제품 코드에 대한 이해도를 높일겸 리펙토링을 진행하려 했다.

내가 가장 처음 느꼈던 부분은 기존 코드가 여러 개발자 분들의 손을 거치다보니 여러 라이브러리와 스타일링 방법이 혼재되어있다는 부분이었다.

우선 [Chakra-ui](https://chakra-ui.com/)를 기반으로 주로 CSS-in-JS 방식의 emotion과 styled-components가 혼재되어있었고 중간중간 리렌더링을 고려하지 않은 inline-style 코드들이 보였다.

CSS-in-JS 방식 자체는 요즘 트렌드이기도 하고 WEWIN의 제품이 성능 자체가 중요한것은 아니라고 판단되었기 때문에 그리 큰 문제는 아니었지만 이런식의 스타일링 컨벤션이 없는 상태로 제품 개발이 계속 진행되다 보면 결국 기술부채가 쌓이고 언젠가 이를 상환하기 위해 더 큰 리소스를 투입해야 된다고 생각했기 때문에 아직 제품 코드가 쌓이기 전에 이를 정리하고 가고싶다는 생각이었다.

## 컴포넌트 스타일링 스택 후보

다음은 내가 고민했던 기술 스택들에 대한 장단점과 나의 의견을 정리해본것이다.

우선 다음과 같은 이유에서 inline-style로 작성된 코드들은 적용범위가 적고 우선순위가 높아 편리하지만 렌더링 할때마다 객체 주소가 바뀌고 이를 리액트는 가상 DOM 변화라고 인식하기 때문에 불필요한 리렌더를 발생시켜 제외하고 꼭 필요한 경우가 아니라면 최대한 걷어내기로 했다.

물론 css 객체를 메모제이션 하면 이부분은 일정 부분 해소 가능하지만 굳이 CSS-in-JS 방식에 좋은 대안들이 많은데 이방법을 사용하는건 비효율 적이라는 생각이다.

### <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>JavaScript</title><path d="M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z"/></svg> CSS-in-JS

#### 장점

- 필요한 컴포넌트 페이지의 스타일 요소만 로딩함
- 파일 관리가 편함 / 컴포넌트간 완전한 분리가 보장 / 모듈성
- 스타일링 우선순위에 대한 고민이 비교적 적음
- JS 환경을 최대한 활용함
- 자바스크립트와 CSS 사이의 상수와 함수를 공유함 (이부분이 가장 포기하기 힘든 부분)
- 트렌디함 / 요즘 많은 개발자들이 선호하는 방식

#### 단점

- CSS-in-CSS 방식에 비해 성능이 떨어짐<br/>
  [Tomas Pustelnik / Real-world CSS vs. CSS-in-JS performance comparison](https://pustelto.com/blog/css-vs-css-in-js-perf/)<br/> (요약하자면 앱의 속도 개선을 위해서는 JS 절대량을 줄여라)

- 스크립트 파일의 크기가 커지면 가독성을 해침 (특히 포메터를 사용할 경우)

#### 의견

- 단점보다 장점이 많다.
- 팀원간의 컨벤션 확립후 적절하게 사용하는것이 바람직하다.

#### 관련 스택

- Emotion
- Styled-Components

만약 위 두 기술스택중 선택한다면 Emotion을 선택할것 같다.

잘 정리된 포스트가 있는데 가서 읽어 보는것도 좋을것 같다.<br/>[bepyan.log / styled-components 과 emotion, 도대체 차이가 뭔가?](https://velog.io/@bepyan/styled-components-%EA%B3%BC-emotion-%EB%8F%84%EB%8C%80%EC%B2%B4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%94%EA%B0%80)

### <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>CSS3</title><path d="M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z"/></svg> CSS-in-CSS

#### 장점

- 가장 일반적이고 기초적인 스타일링 방법이기 떄문에 Front-end 추후 합류할 다른 개발자들도 별도의 학습이 필요없다.<br/>(물론 CSS에서 제공하는 모든 기능을 잘 쓰냐는 다른 문제)
- CSS-in-JS 방식보다 일반적인 상황에서 빠름
- 추가적인 의존성 없이 사용 가능
- CSS-in-JS 방식보다 재사용성이 조금더 낫다는 생각
- Stylesheet 파일 분리로 인해 준수한 가독성

#### 단점

- 변동적인 값에 대한 핸들링이 불편함
- 디테일한 컨벤션 없이는 규모가 커질수록 협업이 힘들 수 있음 (클래스 속성 중복등)
- 파일 구조에 대한 고민이 필요함
- 우선순위에 대한 많은 고민이 필요함

#### 관련 스택

- CSS-Modules
- SASS(SCSS)

## 최종 선택

결론적으로 나는 SCSS 형식을 사용해 CSS-Modules 방식으로 리팩토링을 진행하기로 했다.

여러가지 이유가 있겠지만 내가 가장 끌렸던 부분은 성능적인 부분이다.<br/> (참고로 나는 JS 내장함수들도 브라우저별 성능을 비교해보고 쓸정도로 최적화에 관심이 많다.)

사실 WEWIN 제품들 그렇게 성능이 크게 필요한 제품도 아니고 SSR 방식으로 배포한다고 가정하면 더더욱 성능에서는 차이가 없다.

하지만 현재 우리는 교육 기업들이 학생관리에 사용할 B2B 어드민과 실제 학생들이 보게될 B2C 페이지, 코드스테이츠 내부 크루들이 사용할 백오피스 어드민 이렇게 총 3가지를 개발하고 있다.

이중 SSR이 필요한 제품은 B2C 페이지 밖에 없기 때문에 SSR을 상정하고 개발을 진행하기엔 무리가 있다.

현재는 미세한 차이긴 하지만 나중에는 어떤기능을 지원하게 될지 모르는 상황에서 이런 성능적 이점을 챙기지 않을 이유가 없었다.<br/>(기존 코드가 대부분 CSS-in-JS 방식으로 작성되었기 떄문에 할일이 더 많아지긴 했지만)

그리고 내 기준으로 CSS-in-CSS 방식이 가독성이 좀더 좋다고 느꼈다.

### SASS를 사용한 이유

기본 CSS 대신 SASS를 사용한 이유는 여러기지 편의성 함수들과 스타일시트간 import의 성능 차이 떄문이다<br/>(기본적으로 CSS의 @import는 병렬적으로 처리되지 않는다.)

관련된 내용들은 다음 포스트에 잘 정리되어있다.<br/>
[yceffort / CSS 성능 향상 시키기](https://yceffort.kr/2021/03/improve-css-performance)

최근에 SASS에서 지원하는 여러가지 기능들이 CSS에서도 지원되기 시작했지만 아직 실험적인 기능들이 많고 브라우저별 호환성도 천차만별이라 SASS를 선택했다.

### CSS-Modules을 사용한 이유

CSS-Modules을 사용한 이유는 CSS-in-JS 처럼 컴포넌트간 분리를 원했으며 클래스명 작명 컨벤션을 만드는것 보다 컴포넌트 단위로 스타일시트가 종속되는게 구조 파악에 용이하고 생각했기 떄문이다.

조금 덧붙이자면 Next.js는 [9.3 ver](https://nextjs.org/blog/next-9-3#built-in-sass-css-module-support-for-component-level-styles) 이후 CSS-Modules 방식을 권장했다.

B2C 페이지에 Next.js 도입을 고려하는 상황에서 CSS-Modules을 사용하는 방향으로 컨벤션을 확립한다면 추후 발생 가능한 혼란을 최소화 할수 있다고 생각했다.

<br/>내 개인적인 선호가 영향을 주지 않았다면 거짓말이겠지만 적어도 레퍼런스와 고민없이 선택한것이 아니라고 말하고싶다.

추가적으로 이러한 방밥을 적용하고 이후 개발 패턴을 적용했을때 효율적인 파일구조가 어떤것일지 고민해봐야할것 같다.
